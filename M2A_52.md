# M2#A52 - Paginação - implementação inicial

### Desabilitando error no standard em funcões globais
Para remover esse tipo de error no standard basta adicionar o seguinte propriedade no arquivo `package.json`.

```
"standard": {
    "globals": [
      "alert",
      "test",
      "it",
      "describe"
    ]
  }
```

### Escrevendo testes
Criamos o arquivo dentro do caminho `utils/pagination/pagination.test.js`

Importantdo as dependências de teste
```
import { expect } from 'chai'
import pagination from './index'
```

Testando se é uma função (teste 1)

```
test('pagination should be a function', () => {
  expect(pagination).to.be.a('function')
})
```

Testando o total de páginas (teste 2 e 3)
```
test('pagination({ total: 1, activePage: 1 }) should return [1]', () => {
  const params = { total: 1, activePage: 1 }
  const result = [1]
  expect(pagination(params)).to.be.deep.equal(result)
})

test('pagination({ total: 2, activePage: 1 }) should return [1]', () => {
  const params = { total: 2, activePage: 1 }
  const result = [1, 2]
  expect(pagination(params)).to.be.deep.equal(result)
})
```

#### Criando a função e passando nos testes

No ECMA 5 passamos os parâmetros da seguinte forma

#### Passa no teste 1
```

const pagination = (params) => {
  params.total
  params.activePage
  return [1]
}
```

**Graças ao ES6 conseguimos utilizar destructing nos parâmetros com obj**

```
const pagination = ({ total, activePage }) => { ... }
```

#### Passando no teste 1 e teste 2

Essa é a forma iperativa que estamos utilizando
```
const pagination = ({ total, activePage }) => {
  let pages = []
  for (let i = 0; i < total; i++){
    pages.push(i + 1)
  }
  return pages
}
```
mais podemos utilizar essa abaixo que é um pouco mais funcional utilizando ES5

```
const pagination = ({ total, activePage }) => { 
  return Array.apply(null, { length: total }).map((_, i) => i + 1).map((_, i) => i + 1)
}

```


